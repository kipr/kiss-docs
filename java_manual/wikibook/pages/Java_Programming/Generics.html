<html><head><title>Java Programming/Generics</title><link media="all" href="../../misc/modern.css" type="text/css" rel="stylesheet"></head><body class="mediawiki"><div id="content"><h1 class="firstHeading" id="firstHeading">Java Programming/Generics</h1><div id="bodyContent">
								
				
				
								
				
				
																
				
				
								
				<div lang="en" dir="ltr" class="mw-content-ltr"><table class="wikitable" style="float: right;"><tr><td>Navigate <b><a href="Language_Fundamentals.html" title="Java Programming/Language Fundamentals">Language Fundamentals</a></b> topic: 
<ul><li> <a href="Variables.html" title="Java Programming/Variables">Variables</a></li>
<li> <a href="Flow_control.html" title="Java Programming/Flow control">Flow control</a></li>
<li> <a href="Arrays.html" title="Java Programming/Arrays">Arrays</a></li>
<li> <a href="Methods.html" title="Java Programming/Methods">Methods</a></li>
<li> <a href="Statements.html" title="Java Programming/Statements">Statements</a></li>
<li> <a href="http://en.wikibooks.org/w/index.php?title=Java_Programming/Identifiers,_literals_and_expressions&amp;action=edit&amp;redlink=1" class="new" title="Java Programming/Identifiers, literals and expressions (does not exist)">Identifiers, literals and expressions</a></li>
<li> <a href="Types.html" title="Java Programming/Types">Types</a></li>
<li> <a href="API/java.lang.String.html" title="Java Programming/API/java.lang.String">String</a></li>
<li> <a href="Classes,_Objects_and_Types.html" title="Java Programming/Classes, Objects and Types">Classes, Objects and Types</a></li>
<li> <a href="Syntax.html" title="Java Programming/Syntax">Syntax</a></li>
<li> <a href="Keywords/assert.html" title="Java Programming/Keywords/assert">Assertions</a></li>
<li> <a href="Keywords.html" title="Java Programming/Keywords">Keywords</a></li>
<li> <a href="Packages.html" title="Java Programming/Packages">Packages</a></li>
<li> <a href="Nested_Classes.html" title="Java Programming/Nested Classes">Nested classes</a></li>
<li> <a href="Access_Modifiers.html" title="Java Programming/Access Modifiers">Access modifiers</a></li>
<li> <a href="Data_and_Variables.html" title="Java Programming/Data and Variables">Data and variables</a></li>
<li> <strong class="selflink">Generics</strong></li>
<li> <a href="Java_Security.html" title="Java Programming/Java Security">Java Security</a></li>
</ul></td>
</tr></table><p>Generics were added to the Java language syntax in version 1.5. This means that code using Generics will not compile with Java 1.4 and less.</p>
<p>Java was long criticized for the need to explicitly type-cast an element when it was taken out of a "container/collection" class. There was no way to enforce that a "collection" class contains only one type of object (e.g., to forbid <i>at compile time</i> that an <code>Integer</code> object is added to a <code>Collection</code> that should only contain <code>String</code>s). This is now possible since Java 1.5.</p>
<p>In the first couple of years of Java evolution, Java did not have a real competitor. This has changed by the appearance of Microsoft C#. With Generics Java is better suited to compete against C#. Similar constructs to Java Generics exist in other languages, see <a href="http://en.wikipedia.org/wiki/Generic_programming" class="extiw" title="w:Generic programming">w:Generic programming</a> for more information.</p>
<table id="toc" class="toc"><tr><td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul><li class="toclevel-1 tocsection-1"><a href="http://en.wikibooks.org/w/index.php?title=Java_Programming/Generics&amp;printable=yes#What_are_Generics.3F"><span class="tocnumber">1</span> <span class="toctext">What are Generics?</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="http://en.wikibooks.org/w/index.php?title=Java_Programming/Generics&amp;printable=yes#Introduction"><span class="tocnumber">2</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="http://en.wikibooks.org/w/index.php?title=Java_Programming/Generics&amp;printable=yes#Note_for_C.2B.2B_programmers"><span class="tocnumber">3</span> <span class="toctext">Note for C++ programmers</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="http://en.wikibooks.org/w/index.php?title=Java_Programming/Generics&amp;printable=yes#Class.3CT.3E"><span class="tocnumber">4</span> <span class="toctext">Class&lt;T&gt;</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="http://en.wikibooks.org/w/index.php?title=Java_Programming/Generics&amp;printable=yes#Variable_Argument"><span class="tocnumber">5</span> <span class="toctext">Variable Argument</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="http://en.wikibooks.org/w/index.php?title=Java_Programming/Generics&amp;printable=yes#Wildcard_Types"><span class="tocnumber">6</span> <span class="toctext">Wildcard Types</span></a></li>
</ul></td>
</tr></table><h2> <span class="mw-headline" id="What_are_Generics.3F">What are Generics?</span></h2>
<p>Generics are so called because this language feature allows methods to be written generically, with no foreknowledge of the type on which they will eventually be called upon to carry out their behaviors. A better name might have been <b>type parameter argument</b>. Because, it is basically that, to pass a Type as a parameter to a class at creation time.</p>
<p>When an object is created, parameters can be passed to the created object, through the constructor. Now with Generics, we can also pass in Types. The type-place-holders will be replaced with the specified type, before the object is created.</p>
<p>Type parameter arguments can be set:</p>
<dl><dt>for a class&#160;</dt>
<dd>When an object is created from that class the type-parameter-argument will be replaced with the actual Type.</dd>
</dl><pre>
<code><a href="Keywords/public.html" title="Java Programming/Keywords/public"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">public</font></a></code> <code><a href="Keywords/class.html" title="Java Programming/Keywords/class"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">class</font></a></code> Person&lt;T&gt; 
{
   private Person&lt;T&gt; person;
...
}
...
// --- Create an Employee person ---
Person&lt;Employee&gt; emplPerson = <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> Person&lt;Employee&gt;(); 
...
// --- Create a Customer person ---
Person&lt;Customer&gt; custPerson = <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> Person&lt;Customer&gt;();
</pre>
<dl><dt>for a method&#160;</dt>
<dd>Just like class declarations, method declarations can be generic--that is, parameterized by one or more type parameters.</dd>
</dl><pre>
<code><a href="Keywords/public.html" title="Java Programming/Keywords/public"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">public</font></a></code> <code><a href="Keywords/static.html" title="Java Programming/Keywords/static"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">static</font></a></code> &lt;T&gt; <code><a href="Keywords/void.html" title="Java Programming/Keywords/void"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">void</font></a></code> assign( Person&lt;T&gt; person, T obj ) 
{
   person.setPerson( obj );
}
</pre>
<dl><dt>use of generics is optional&#160;</dt>
<dd>For backwards compatibility with pre-Generics code, it is okay to use generic classes without the generics type specification thing (<code>&lt;T&gt;</code>). In such a case, when you retrieve an object reference from a generic object, you will have to manually typecast it from type Object to the correct type. The compiler should also warn about unsafe operations.</dd>
</dl><h2> <span class="mw-headline" id="Introduction">Introduction</span></h2>
<p>Java is a strongly typed language. That's one of the reasons why it is so easy to use. Many potential problems are caught by the compiler. One area where Java was criticized was regarding the container objects. Container objects are objects that contain other objects. Before Generics were introduced there was no way to ensure that a container object contains only one type of objects. When an object was added to a container, it was automatically cast to Java <code><a href="API/java.lang.Object.html" title="Java Programming/API/java.lang.Object">Object</a></code>. When it was taken out an explicit cast was needed. Normally an explicit cast is checked by the compiler.</p>
<pre>
<code><a href="API/java.lang.String.html" title="Java Programming/API/java.lang.String">String</a></code> st = "This is a String";
...
Integer integer = (Integer) st;  // --- <b>Compilation Error</b> -- 
</pre>
<p>But in the case of container classes, the compiler was not able to catch an invalid type casting.</p>
<pre>
1 Collection collString = <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> ArrayList();
2 collString.add( "This is a String" );
...
3 Integer integer = (Integer) collString.get(0);  // --- <b>No Compilation Error; RunTime CastException</b>
</pre>
<p>Just looking at line 3, we do not know what type of objects <i>collString</i> contains. If that contains Integers then the code is fine.</p>
<p>The below code using Generic:</p>
<pre>
Collection&lt;<code><a href="API/java.lang.String.html" title="Java Programming/API/java.lang.String">String</a></code>&gt; collString = <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> ArrayList&lt;<code><a href="API/java.lang.String.html" title="Java Programming/API/java.lang.String">String</a></code>&gt;();
collString.add( "This is a String" );
...
Integer integer = (Integer) collString.get(0);  // --- <b>Compilation Error</b>
</pre>
<p><i>collString</i> is a container object, that can contain only <i>String</i> objects, nothing else, so when we get out an element it can be casted only to class that normally a String can be casted.</p>
<p>With Generics, Java strict type checking can be extended to container objects. Using Generics with container classes, gives an impression that a new container type is created, with each different type parameter. Before Generics:</p>
<pre>
Collection collCustomer = <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> ArrayList();
collCustomer.add( <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> Customer() );
...
Collection collObject = collCustomer;  // --- <b>No problem, both collObject and collCustomer have the same type</b>
</pre>
<p>With generics:</p>
<pre>
Collection&lt;Customer&gt; collCustomer = <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> ArrayList&lt;Customer&gt;();
collCustomer.add( <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> Customer() );
...
Collection&lt;Object&gt; collObject = collCustomer;  // --- <b>Compilation Error</b>
</pre>
<p>Both <i>collObject</i> and <i>collCustomer</i> have the same type, <b>BUT it is against the Generic rule</b>, that is <i>collCustomer</i> can contain only Customer objects, and <i>collObject</i> can contain only Object object. So there is an additional check to the normal type checking, the type of the parameter type has to be matched too.</p>
<h2> <span class="mw-headline" id="Note_for_C.2B.2B_programmers">Note for C++ programmers</span></h2>
<p>Java Generics are similar to C++ Templates in that both were added for the same reason. The syntax of Java Generic and C++ Template are also similar.</p>
<p>There are some differences however. The C++ template can be seen as a kind of macro, that generates code before compilation. The generated code depends on how the Template class is referenced. The amount of code generated depends on how many different types of classes are created from the Template. C++ Templates do not have any run-time mechanisms. The compiler creates normal code to substitute the template, similar to any 'hand-written' code.</p>
<p>In contrast, Java Generics are built into the language. The same Class object handles all the Generic type variations. No additional code is generated, no matter how many Generic objects are created with different type parameters. For example.</p>
<pre>
Collection&lt;String&gt;  collString  = <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> ArrayList&lt;<code><a href="API/java.lang.String.html" title="Java Programming/API/java.lang.String">String</a></code>&gt;();

Collection&lt;Integer&gt; collInteger = <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> ArrayList&lt;Integer&gt;();
</pre>
<p>There is only one Class object created. In fact, at runtime, both these objects appear as the same type (both <code>ArrayList</code>'s). The generics type information is erased during compilation (type erasure). This means, for example, that if you had function that takes <code>Collection&lt;T&gt;</code> as an argument, and that collection happened to be empty, your function would have no way of instantiating another <code>T</code> object, because it doesn't know what <code>T</code> was.</p>
<p>The Class <code><a href="Keywords/class.html" title="Java Programming/Keywords/class"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">class</font></a></code> itself is generic since Java 1.5.</p>
<pre>
<code><a href="Keywords/public.html" title="Java Programming/Keywords/public"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">public</font></a></code> <code><a href="Keywords/final.html" title="Java Programming/Keywords/final"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">final</font></a></code> <code><a href="Keywords/class.html" title="Java Programming/Keywords/class"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">class</font></a></code> <b>Class&lt;T&gt;</b> <code><a href="Keywords/extends.html" title="Java Programming/Keywords/extends"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">extends</font></a></code> <code><a href="API/java.lang.Object.html" title="Java Programming/API/java.lang.Object">Object</a></code> 
                      <code><a href="Keywords/implements.html" title="Java Programming/Keywords/implements"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">implements</font></a></code> Serializable, GenericDeclaration, Type, AnnotatedElement
{
...
}
</pre>
<p>The <b>T</b> type here represents the type that is handed to the Class object. The <b>T</b> type will be substituted with the class being loaded.</p>
<h2> <span class="mw-headline" id="Class.3CT.3E">Class&lt;T&gt;</span></h2>
<p>Since Java 1.5, the class java.lang.Class is generic. It is an interesting example of using genericness for something other than a container class.</p>
<p>For example, the type of String.class is <code>Class&lt;String&gt;</code>, and the type of Serializable.class is <code>Class&lt;Serializable&gt;</code>. This can be used to improve the type safety of your <b>reflection code</b>.</p>
<p>In particular, since the <code>newInstance()</code> method in Class now returns a T, you can get more precise types when creating objects reflectively.</p>
<dl><dt>Now we can use the <code>newInstance()</code> method to return a new object with exact type, without casting.&#160;</dt>
</dl><pre>
Customer cust = Utility.<b>createAnyObject</b>(Customer.class);  // - <b>No casting</b>
...
<code><a href="Keywords/public.html" title="Java Programming/Keywords/public"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">public</font></a></code> <code><a href="Keywords/static.html" title="Java Programming/Keywords/static"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">static</font></a></code> &lt;T&gt; T <b>createAnyObject</b>(Class&lt;T&gt; cls)
{
    T ret = <code><a href="Literals/null.html" title="Java Programming/Literals/null"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">null</font></a></code>; 
    <code><a href="Keywords/try.html" title="Java Programming/Keywords/try"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">try</font></a></code>
    {
        ret = cls.newInstance();
    }
    <code><a href="Keywords/catch.html" title="Java Programming/Keywords/catch"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">catch</font></a></code> (Exception e)
    {
        // --- Exception Handling
    }
    <code><a href="Keywords/return.html" title="Java Programming/Keywords/return"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">return</font></a></code> ret;
}
</pre>
<p>And the above code without Generics:</p>
<pre>
Customer cust = <b>(Customer)</b> Utility.createAnyObject(Customer.class);  // - <b>Casting is needed</b>
...
<code><a href="Keywords/public.html" title="Java Programming/Keywords/public"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">public</font></a></code> <code><a href="Keywords/static.html" title="Java Programming/Keywords/static"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">static</font></a></code> <code><a href="API/java.lang.Object.html" title="Java Programming/API/java.lang.Object">Object</a></code> createAnyObject(Class cls)
{
    Object ret = <code><a href="Literals/null.html" title="Java Programming/Literals/null"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">null</font></a></code>; 
    <code><a href="Keywords/try.html" title="Java Programming/Keywords/try"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">try</font></a></code>
    {
        ret = cls.newInstance();
    }
    <code><a href="Keywords/catch.html" title="Java Programming/Keywords/catch"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">catch</font></a></code> (Exception e)
    {
        // --- Exception Handling
    }
    <code><a href="Keywords/return.html" title="Java Programming/Keywords/return"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">return</font></a></code> ret;    
}
</pre>
<dl><dt>Get exact type when getting JavaBean property, using reflection&#160;</dt>
<dd>See the following code where the method will return the exact type of the Java Bean property, based on how it will be called.</dd>
</dl><pre>
// --- Using reflection, get a Java Bean property by its name ---
<code><a href="Keywords/public.html" title="Java Programming/Keywords/public"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">public</font></a></code> <code><a href="Keywords/static.html" title="Java Programming/Keywords/static"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">static</font></a></code> &lt;T&gt; T getProperty(Object bean, String propertyName)
{
    <code><a href="Keywords/if.html" title="Java Programming/Keywords/if"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">if</font></a></code> (bean == <code><a href="Literals/null.html" title="Java Programming/Literals/null"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">null</font></a></code> ||
        propertyName == <code><a href="Literals/null.html" title="Java Programming/Literals/null"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">null</font></a></code> ||
        propertyName.length() == 0)
    {
        <code><a href="Keywords/return.html" title="Java Programming/Keywords/return"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">return</font></a></code> <code><a href="Literals/null.html" title="Java Programming/Literals/null"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">null</font></a></code>;
    }
    // --- Based on the property name build the getter method name ---
    <code><a href="API/java.lang.String.html" title="Java Programming/API/java.lang.String">String</a></code> methodName = "get" +
        propertyName.substring(0,1).toUpperCase() +
        propertyName.substring(1);
    T property = <code><a href="Literals/null.html" title="Java Programming/Literals/null"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">null</font></a></code>;
    <code><a href="Keywords/try.html" title="Java Programming/Keywords/try"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">try</font></a></code>
    {
        java.lang.Class c = bean.getClass();
        java.lang.reflect.Method m = c.getMethod(methodName, <code><a href="Literals/null.html" title="Java Programming/Literals/null"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">null</font></a></code>);
        property = (T) m.invoke(bean, <code><a href="Literals/null.html" title="Java Programming/Literals/null"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">null</font></a></code>);
    }
    <code><a href="Keywords/catch.html" title="Java Programming/Keywords/catch"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">catch</font></a></code> (Exception e)
    {
        // --- Handle exception --
    }
    <code><a href="Keywords/return.html" title="Java Programming/Keywords/return"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">return</font></a></code> property;
}
</pre>
<h2> <span class="mw-headline" id="Variable_Argument">Variable Argument</span></h2>
<p>Using Generics, it is very easy to define a method with a variable number of arguments. Before generics, this was not possible in Java&#8212;if a likewise feature was needed, this was mostly done by passing an array. The only requirement for using a variable number of arguments using Generics is that the arguments in the list must have the same type.</p>
<p>The following code illustrates a method that can be called with a variable number arguments:</p>
<pre>
/**
 * Method using variable-length argument list
 * @param &lt;T&gt;
 * @param args
 */
<code><a href="Keywords/public.html" title="Java Programming/Keywords/public"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">public</font></a></code> <code><a href="Keywords/static.html" title="Java Programming/Keywords/static"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">static</font></a></code> &lt;T&gt; List&lt;T&gt; makeAList(T... args)
{
    List&lt;T&gt; argList = <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> ArrayList&lt;T&gt;();
    <code><a href="Keywords/for.html" title="Java Programming/Keywords/for"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">for</font></a></code> (<code><a href="Keywords/int.html" title="Java Programming/Keywords/int"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">int</font></a></code> i = 0; i &lt; args.length; i++)
    {
        argList.add(args[i]);
    }
    <code><a href="Keywords/return.html" title="Java Programming/Keywords/return"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">return</font></a></code> argList;
}
</pre>
<p>The above method can be called with a variable number of arguments, for example:</p>
<pre>
List&lt;<code><a href="API/java.lang.String.html" title="Java Programming/API/java.lang.String">String</a></code>&gt; list1 = makeAList("One", "Two", "Three");
List&lt;<code><a href="API/java.lang.String.html" title="Java Programming/API/java.lang.String">String</a></code>&gt; list2 = makeAList("One", "Two", "Three", "Four");
</pre>
<p>In the above example calls, the arguments must be of type <code>String</code>. If we write <tt>&lt;? extends Object&gt;</tt> instead of <tt>T</tt>, then we can pass <i>any</i> kind of objects, regardles of their type:</p>
<pre>
List&lt;? extends Object&gt; list3 = makeAList("One", 10, new StringBuffer(), new LinkedList());
</pre>
<p>Note: the number 10 in the above code will be converted (autoboxed) to Integer.</p>
<p>See also:</p>
<pre>
java.util.Arrays.asList(T... a)
</pre>
<h2> <span class="mw-headline" id="Wildcard_Types">Wildcard Types</span></h2>
<p>As we have seen above, generics give the impression that a new container type is created with each different type parameter. We have also seen that in addition to the normal type checking, the type parameter has to match as well when we assign generics variables.</p>
<p>In some cases this is too restrictive. What if we would like to relax this additional checking? What if we would like to define a collection variable that can hold any generic collection, regardless of the parameter type it holds?</p>
<dl><dt>Wildcard&#160;</dt>
<dd>The wildcard type is represented by the character <b>&lt;?&gt;</b>, and pronounced <b>Unknown</b>, or <b>Any-Type</b>. This <b>Unknown</b> type matches anything, if it is used only by itself. Any-Type can be express also by <code>&lt;? extends Object&gt;</code>. Any-Type includes Interfaces, not only Classes.</dd>
</dl><p>So now we can define a collection whose element type matches anything. See below:</p>
<pre>
Collection&lt;?&gt; collUnknown;
</pre>
<p>Note that we can not add anything to this collection. We can only take out elements of type <code><a href="API/java.lang.Object.html" title="Java Programming/API/java.lang.Object">Object</a></code> from it. So what is the use of this variable if we can not add anything to the collection it represents? The use of this new construct will be clear when you want to create a generic method that takes any collection.</p>
<pre>
<code><a href="Keywords/public.html" title="Java Programming/Keywords/public"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">public</font></a></code> <code><a href="Keywords/static.html" title="Java Programming/Keywords/static"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">static</font></a></code> <code><a href="Keywords/void.html" title="Java Programming/Keywords/void"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">void</font></a></code> printElements( Collection&lt;?&gt; anycoll )
{
   Iterator&lt;?&gt; iter = anycoll.iterator();
   <code><a href="Keywords/while.html" title="Java Programming/Keywords/while"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">while</font></a></code> ( iter.hasNext() )
   {
      System.out.print( iter.next() );
   }    
}
</pre>
<dl><dt>Wildcard for a specific type of classes&#160;</dt>
</dl><p><b>"&lt;? extends ClassName&gt;"</b> specifies a restriction on the types of classes that may used.</p>
<p>For example, to create a collection that may only contain "Serializable" objects, specify:</p>
<pre>
Collection<b>&lt;? extends Serializable&gt;</b> serColl = new ArrayList&lt;<code><a href="API/java.lang.String.html" title="Java Programming/API/java.lang.String">String</a></code>&gt;();
</pre>
<p>The above code is valid because, the <code><a href="API/java.lang.String.html" title="Java Programming/API/java.lang.String">String</a></code> class is serializable. Use of a class that is not serializable would cause a compilation error.</p>
<p>The following collection can only contain objects that extend the class Animal.</p>
<pre>
<code><a href="Keywords/class.html" title="Java Programming/Keywords/class"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">class</font></a></code> Dog <code><a href="Keywords/extends.html" title="Java Programming/Keywords/extends"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">extends</font></a></code> Animal
{
 ...
}
...
// --- Create "Animal Collection" variable ---
Collection<b>&lt;? extends Animal&gt;</b> animalColl = <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> ArrayList&lt;Dog&gt;();
</pre>
<p><b>"&lt;? super ClassName&gt;"</b> specifies a restriction on the types of classes that may be used.</p>
<p>For example, to declare a Comparator that can compare Dogs, you use</p>
<pre>
Comparator<b>&lt;? super Dog&gt;</b> myComparator;
</pre>
<p>Now suppose you define a comparator that can compare Animals:</p>
<pre>
<code><a href="Keywords/class.html" title="Java Programming/Keywords/class"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">class</font></a></code> AnimalComparator <code><a href="Keywords/implements.html" title="Java Programming/Keywords/implements"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">implements</font></a></code> Comparator&lt;Animal&gt;
{
  int compare(Animal a, Animal b) { //...
  }
}

</pre>
<p>Since Dogs are Animals, you can use this comparator to compare Dogs also. Comparators for any superclass of Dog can also compare Dog; but comparators for any strict subclass cannot.</p>
<pre>
Comparator<b>&lt;Animal&gt;</b> myAnimalComparator = <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> AnimalComparator();

static int compareTwoDogs(Comparator&lt;? super Dog&gt; comp, Dog dog1, Dog dog2) {
  return comp.compare(dog1, dog2);
}
</pre>
<p>The above code is valid because, the <code>Animal</code> class is a supertype of the <code>Dog</code> class. Use of a class that is not a supertype would cause a compilation error.</p>





</div>				
								
				
				
												
								
												
				
				
								<div class="visualClear"></div>
				
								
			</div>
			</div></body></html>