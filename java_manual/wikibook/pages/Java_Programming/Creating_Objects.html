<html><head><title>Java Programming/Creating Objects</title><link media="all" href="../../misc/modern.css" type="text/css" rel="stylesheet"></head><body class="mediawiki"><div id="content"><h1 class="firstHeading" id="firstHeading">Java Programming/Creating Objects</h1><div id="bodyContent">
								
				
				
								
				
				
																
				
				
								
				<div lang="en" dir="ltr" class="mw-content-ltr"><table class="wikitable" style="float: right;"><tr><td>Navigate <b><a href="Classes_and_Objects.html" title="Java Programming/Classes and Objects">Classes and Objects</a></b> topic: 
<ul><li><a href="Defining_Classes.html" title="Java Programming/Defining Classes">Defining classes</a></li>
<li><strong class="selflink">Creating objects</strong></li>
<li><a href="Interfaces.html" title="Java Programming/Interfaces">Interfaces</a></li>
<li><a href="Using_Static_Members.html" title="Java Programming/Using Static Members">Using static members</a></li>
<li><a href="Destroying_Objects.html" title="Java Programming/Destroying Objects">Destroying objects</a></li>
<li><a href="Overloading_Methods_and_Constructors.html" title="Java Programming/Overloading Methods and Constructors">Overloading methods and constructors</a></li>
<li><a href="Class_Loading.html" title="Java Programming/Class Loading">Class Loading</a></li>
</ul></td>
</tr></table><table id="toc" class="toc"><tr><td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul><li class="toclevel-1 tocsection-1"><a href="http://en.wikibooks.org/w/index.php?title=Java_Programming/Creating_Objects&amp;printable=yes#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="http://en.wikibooks.org/w/index.php?title=Java_Programming/Creating_Objects&amp;printable=yes#Creating_object_with_the_new_keyword"><span class="tocnumber">2</span> <span class="toctext">Creating object with the new keyword</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="http://en.wikibooks.org/w/index.php?title=Java_Programming/Creating_Objects&amp;printable=yes#Creating_object_by_cloning_an_object"><span class="tocnumber">3</span> <span class="toctext">Creating object by cloning an object</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="http://en.wikibooks.org/w/index.php?title=Java_Programming/Creating_Objects&amp;printable=yes#Creating_object_receiving_from_a_remote_source"><span class="tocnumber">4</span> <span class="toctext">Creating object receiving from a remote source</span></a></li>
</ul></td>
</tr></table><h2> <span class="mw-headline" id="Introduction">Introduction</span></h2>
<p>Before a Java object can be created the class byte code must be loaded from the file system (with .class extension) to memory. This process of locating the byte code for a given class name and converting that code into a Java <a href="API/java.lang.Class.html" title="Java Programming/API/java.lang.Class">Class</a> class instance is known as class loading. There is one <a href="API/java.lang.Class.html" title="Java Programming/API/java.lang.Class">Class</a> created for each type of Java class.</p>
<p>All objects in java programs are created on heap memory. An object is created based on its class. You can consider a class as a blueprint, template, or a description how to create an object. When an object is created, memory is allocated to hold the object properties. An object reference pointing to that memory location is also created. To use the object in the future, that object reference has to be stored as a local variable or as an object member variable.</p>
<p>The Java Virtual Machine (JVM), keeps track of the usage of object references. If there are no more reference to the object, the object can not be used any more and becomes garbage. After a while the heap memory will be full of unused objects. The JVM collects those garbage objects and frees the memory they allocated, so the memory can be reused again when a new object is created. See below a simple example:</p>
<pre>
{
  // --- Create an object ---
  MyObject obj = <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> MyObject();

  // --- Use the object ---
  obj.printMyValues();
}
</pre>
<p>The <code>obj</code> contains the object reference pointing to an object created from the MyObject class. The <code>obj</code> object reference is in scope inside the { }. After the } the object becomes garbage. Object references can be passed in to methods, object references can be returned from methods.</p>
<h2> <span class="mw-headline" id="Creating_object_with_the_new_keyword">Creating object with the <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> keyword</span></h2>
<p>99% of new objects are created using the <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> keyword.</p>
<pre>
{
   // --- Create an 'MyObject' for the first time the application started --
   MyObject obj = <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> MyObject();
}
</pre>
<p>When an object from the MyObject class is created for the first time. The JVM searches the file system for the definition of the class, that is the Java byte code. The file has the extention of '*.class'. The <b>CLASSPATH</b> environment variable contains locations where Java classes are stored. The JVM is looking for the 'MyObject.class' file. Depending on which package the class belongs to, the package name will be translated to a directory path.</p>
<p>When the 'MyObject.class' file is found, the JVM's class loader loads the class in memory, and creates a Class object. The JVM stores the code in memory, allocates memory for the <code><a href="Keywords/static.html" title="Java Programming/Keywords/static"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">static</font></a></code> variables, and executes any static initialize block. Memory is not allocated for the object member variables at this point, memory will be allocated for them when an instance of the class, an object, is created.</p>
<p>There is no limit on how many objects from the same class can be created. Code and <code><a href="Keywords/static.html" title="Java Programming/Keywords/static"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">static</font></a></code> variables are stored only once, no matter how many objects are created. Memory is allocated for the object member variables when the object is created. Thus, the size of an object is determined not by its code's size but by the memory it needs for its member variables to be stored.</p>
<h2> <span class="mw-headline" id="Creating_object_by_cloning_an_object">Creating object by cloning an object</span></h2>
<p>Cloning is not automatically available to classes. There is some help though, as all Java objects inherit the <code>protected Object clone()</code> method. This base method would allocate the memory and do the bit by bit copying of the object's states.</p>
<p>You may ask why we need this clone method. Couldn't I create a constructor and just passing in the same object, and do the copying variable by variable? Lets see:</p>
<pre>
<code><a href="Keywords/public.html" title="Java Programming/Keywords/public"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">public</font></a></code> <code><a href="Keywords/class.html" title="Java Programming/Keywords/class"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">class</font></a></code> MyObject
{
   <code><a href="Keywords/private.html" title="Java Programming/Keywords/private"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">private</font></a></code> int memberVar;
...
   MyObject( MyObject obj )
   {
      this.memberVar = obj.memberVar;
    ...
   }
...
}
</pre>
<p>You might think that accessing the private memberVar variable of obj would fail but as this is in the same class this code is legal. The <code>clone()</code> method copies the whole object's memory in one operation. This is much faster than using the new keyword. Object creation with the <code><a href="Keywords/new.html" title="Java Programming/Keywords/new"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">new</font></a></code> keyword is expensive, so if you need to create lots of objects with the same type, performance will be better if you create one object and clone new ones from it. See below a factory method that will return a new object using cloning.</p>
<pre>
HashTable _cacheTemplate = new HashTable;
...
/** Clone Customer object for performance reason */
<code><a href="Keywords/public.html" title="Java Programming/Keywords/public"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">public</font></a></code> Customer createCustomerObject()
{
   // --- See if a template object exists in our cache ---
   Customer template = _cacheTemplate.get( "Customer" );
   if ( template == null )
   {
      // --- Create template ---
      template = new Customer();
      _cacheTemplate.put( "Customer", template );
   }
  return template.clone();
}
</pre>
<p>Now, lets see how to make the Customer object cloneable.</p>
<ul><li>First the Customer class needs to implement the Cloneable Interface.</li>
<li>Override and make the <code>clone()</code> method <code><a href="Keywords/public.html" title="Java Programming/Keywords/public"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">public</font></a></code>, as that is <code><a href="Keywords/protected.html" title="Java Programming/Keywords/protected"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">protected</font></a></code> in the Object class.</li>
<li>Call the <code>super.clone()</code>method at the beginning of your <code>clone</code> method.</li>
<li>Override the <code>clone()</code> method in all the subclasses of Customer.</li>
</ul><pre>
<code><a href="Keywords/public.html" title="Java Programming/Keywords/public"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">public</font></a></code> <code><a href="Keywords/class.html" title="Java Programming/Keywords/class"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">class</font></a></code> Customer <code><a href="Keywords/implements.html" title="Java Programming/Keywords/implements"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">implements</font></a></code> Cloneable
{
 ...
    <code><a href="Keywords/public.html" title="Java Programming/Keywords/public"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">public</font></a></code> <code><a href="API/java.lang.Object.html" title="Java Programming/API/java.lang.Object">Object</a></code> clone() <code><a href="Keywords/throws.html" title="Java Programming/Keywords/throws"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">throws</font></a></code> CloneNotSupportedException
    {
        Object obj = super.clone();

       return obj;
    }
}
</pre>
<p>In the above example we used cloning for speed up object creation.</p>
<p>An other use of cloning could be to take a snapshot of an object that can change in time. Lets say we want to store Customer objects in a collection, but we want to disassociate them from the 'live' objects . So before adding the object, we clone them, so if the original object changes from that point forward, the added object won't. Also lets say that the Customer object has a reference to an Activity object that contains the customer activities. Now we are facing a problem, it is not enough to clone the Customer object, we also need to clone the referenced objects. The solution:</p>
<ul><li>Make the Activity class also cloneable</li>
<li>Make sure that if the Activity class has other 'changeable' object references, those has to be cloned as well, as seen below</li>
<li>Change the Customer class <code>clone()</code> method as follows:</li>
</ul><pre>
<code><a href="Keywords/public.html" title="Java Programming/Keywords/public"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">public</font></a></code> <code><a href="Keywords/class.html" title="Java Programming/Keywords/class"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">class</font></a></code> Customer <code><a href="Keywords/implements.html" title="Java Programming/Keywords/implements"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">implements</font></a></code> Cloneable
{
  Activity _activity;
  ...
    <code><a href="Keywords/public.html" title="Java Programming/Keywords/public"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">public</font></a></code> Customer clone() <code><a href="Keywords/throws.html" title="Java Programming/Keywords/throws"><font style="color:DodgerBlue4; text-decoration: none; font-weight: bold;">throws</font></a></code> CloneNotSupportedException
    {
        Customer clonedCustomer = (Customer) super.clone();

        // -- Clone the object referenced objects ---
        if ( _activity != null )
        {
            clonedCustomer.setActivity( (Activity) _activity.clone() );
        } 
       return clonedCustomer;
    }
}
</pre>
<p>Note that only mutable objects needs to be cloned. References to unchangeable objects such as String be used in the cloned object without worry.</p>
<h2> <span class="mw-headline" id="Creating_object_receiving_from_a_remote_source">Creating object receiving from a remote source</span></h2>
<p>When an object is sent through a network, the object needs to be <b>recreated</b> at the receiving host.</p>
<dl><dt>Object Serialization&#160;</dt>
<dd>The term Object Serialization refers to the act of converting the object to a byte stream. The byte stream can be stored on the file system, or can be sent through a network.</dd>
<dd>At the later time the object can be re-created from that stream of bytes. The only requirement is that the same class has to be available at both times, when the object is serialized and also when the object is re-created. If that happens in different servers, then the same class must be available on both servers. Same class means that exactly the same version of the class must be available, otherwise the object won't be able to be re-created. This is a maintenance problem to those applications where java serialization is used to persist object or sent the object through the network.</dd>
<dd>When a class is modified, there could be a problem re-creating those objects that were serialized using an earlier version of the class.</dd>
</dl><p>Java has built in support for serialization, using the Serializable interface; however, a class must first implement the Serializable interface.</p>
<p>By default, a class will have all of its fields serialized when converted into a data stream (with <a href="Keywords/transient.html" title="Java Programming/Keywords/transient">transient</a> fields being skipped.) If additional handling is required beyond the default of writing all fields, you need to provide an implementation for two methods:</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;">
<div class="java source-java">
<pre class="de1">
 <span class="kw1">private</span> <span class="kw4">void</span> writeObject<span class="br0">(</span>java.<span class="me1">io</span>.<span class="kw3">ObjectOutputStream</span> out<span class="br0">)</span> <span class="kw1">throws</span> <span class="kw3">IOException</span><span class="sy0">;</span>
 <span class="kw1">private</span> <span class="kw4">void</span> readObject<span class="br0">(</span>java.<span class="me1">io</span>.<span class="kw3">ObjectInputStream</span> in<span class="br0">)</span> <span class="kw1">throws</span> <span class="kw3">IOException</span>, <span class="kw3">ClassNotFoundException</span><span class="sy0">;</span>
 <span class="kw1">private</span> <span class="kw4">void</span> readObjectNoData<span class="br0">(</span><span class="br0">)</span> <span class="kw1">throws</span> <span class="kw3">ObjectStreamException</span><span class="sy0">;</span>
</pre></div>
</div>
<p>If the object needs to write or provide a replacement object during serialization, it needs to implement the following two methods, with any access specifier:</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;">
<div class="java source-java">
<pre class="de1">
 <span class="kw3">Object</span> writeReplace<span class="br0">(</span><span class="br0">)</span> <span class="kw1">throws</span> <span class="kw3">ObjectStreamException</span><span class="sy0">;</span>
 <span class="kw3">Object</span> readResolve<span class="br0">(</span><span class="br0">)</span> <span class="kw1">throws</span> <span class="kw3">ObjectStreamException</span><span class="sy0">;</span>
</pre></div>
</div>
<p>Normally, a minor change to the class can cause the serialization to fail. You can still allow the class to be loaded by defining the serialization version id:</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;">
<div class="java source-java">
<pre class="de1">
 <span class="kw1">private</span> <span class="kw1">static</span> <span class="kw1">final</span> <span class="kw4">long</span> serialVersionUID <span class="sy0">=</span> 42L<span class="sy0">;</span>
</pre></div>
</div>





</div>				
								
				
				
												
								
												
				
				
								<div class="visualClear"></div>
				
								
			</div>
			</div></body></html>